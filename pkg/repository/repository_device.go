/*
 * Devices Microservice
 *
 * Microservice for managing Gi√≤ Plants devices
 *
 * API version: 1.0.0
 * Contact: andrea.liut@gmail.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package repository

import (
	"fmt"
	"gio-device-ms/pkg/model"
	"sync"
)

const (
	maxReadings             = 5000 // Max number or Reading objects stored by the repository
	maintainedReadingsCount = 30   // Number of Reading objects to maintain after cleanup
)

type DeviceRepository struct {
	devicesMutex  *sync.Mutex
	readingsMutex *sync.Mutex

	devices  map[string]*model.Device
	readings map[string][]*model.Reading
}

// Returns a specific device
func (r *DeviceRepository) Get(id string) (*model.Device, error) {
	r.devicesMutex.Lock()
	defer r.devicesMutex.Unlock()

	d, _ := r.devices[id]

	return d, nil
}

// Returns all readings of a specific device
// limit: limits the results set
// name: filter the readings by name
func (r *DeviceRepository) GetReadings(id string, limit int, name string) ([]*model.Reading, error) {
	r.readingsMutex.Lock()
	defer r.readingsMutex.Unlock()

	readings, exists := r.readings[id]
	if !exists {
		return nil, fmt.Errorf("device %s not found", id)
	}

	if name != "" {
		// Filter by name
		filtered := make([]*model.Reading, 0)

		for _, r := range readings {
			if r.Name == name {
				filtered = append(filtered, r)
			}
		}

		readings = filtered
	}

	// Check boundaries
	if limit <= 0 || limit > len(readings) {
		limit = len(readings)
	}

	// take the last limit entries
	idx := len(readings) - limit

	return readings[idx:], nil
}

// Returns all available devices
func (r *DeviceRepository) GetAll(roomId string) ([]*model.Device, error) {
	res := make([]*model.Device, len(r.devices))

	r.devicesMutex.Lock()
	defer r.devicesMutex.Unlock()

	i := 0
	for _, d := range r.devices {
		if roomId == "" || d.Room == roomId {
			res[i] = d
			i++
		}
	}

	return res, nil
}

// Adds a new device
func (r *DeviceRepository) Insert(device *model.Device) (*model.Device, error) {
	device.ID = newID()

	r.devicesMutex.Lock()
	r.readingsMutex.Lock()
	defer r.readingsMutex.Unlock()
	defer r.devicesMutex.Unlock()

	r.devices[device.ID] = device
	r.readings[device.ID] = make([]*model.Reading, 0)

	return device, nil
}

// Adds a new reading to a device
func (r *DeviceRepository) InsertReading(device *model.Device, reading *model.Reading) (*model.Reading, error) {
	reading.ID = newID()

	r.readingsMutex.Lock()
	defer r.readingsMutex.Unlock()

	// Cleanup
	if len(r.readings[device.ID]) >= maxReadings {
		idx := len(r.readings[device.ID]) - maintainedReadingsCount
		r.readings[device.ID] = r.readings[device.ID][idx:]
	}

	r.readings[device.ID] = append(r.readings[device.ID], reading)

	return reading, nil
}

// Returns a device identified by mac
func (r *DeviceRepository) GetByMAC(mac string) (*model.Device, error) {
	r.devicesMutex.Lock()
	defer r.devicesMutex.Unlock()

	for _, device := range r.devices {
		if device.Mac == mac {
			return device, nil
		}
	}

	return nil, nil
}

var deviceRepository *DeviceRepository

func NewDeviceRepository() (*DeviceRepository, error) {
	if deviceRepository == nil {
		deviceRepository = &DeviceRepository{
			devicesMutex:  &sync.Mutex{},
			readingsMutex: &sync.Mutex{},
			devices:       make(map[string]*model.Device),
			readings:      make(map[string][]*model.Reading),
		}
	}

	return deviceRepository, nil
}
